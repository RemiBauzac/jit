---
layout: post
title:  "First language virtual machine"
date:   2018-12-31 
author: RÃ©mi Bauzac

---

In the [previous post](http://jit.bauzac.net/blog/first-language-parser) you built a small language parser and bytecode generator using `lex` and `yacc`.
Now you have to load and interpret the bytecode (it's a really easy thing).

# Loading bytecode
Remember, the parser built bytecode from high level language and dump it to the `out.bc` file.
Loading bytecode is the inverse mechanism :

* Open out.bc file
{% highlight c %}
  bcf = fopen(filename, "rb");
  if (!bcf) {
    fprintf(stderr, "Cannot open %s bytecode\n", filename);
    return NULL;
  }
{% endhighlight %}
* Check file coherency (cookie, version)
{% highlight c %}
  fread(&cookie, sizeof(char), 4, bcf);
  if (cookie != LANG_COOKIE) {
    fprintf(stderr, "Bad bytecode file format\n");
    fclose(bcf);
    return NULL;
  }

  fread(&version, sizeof(char), 4, bcf);
  if (version != LANG_VERSION) {
    fprintf(stderr, "Bad lang version %d. %d was awaited\n", version, LANG_VERSION);
    return NULL;
  }
{% endhighlight %}
* create data structure from file data
{% highlight c %}
  /* Alloc main function structure */
  main = malloc(sizeof(function));
  if (!main) return NULL;

  /* Read 32 bits code size from file */
  fread(&main->codesz, sizeof(uint32_t), 1, bcf);
  if (main->codesz == 0) {
    fprintf(stderr, "Empty bytecode file\n");
    return main;
  }

  /* Alloc code regarding code size */
  main->code = malloc(sizeof(operation)*main->codesz);

  /* Put code to structure */
  codesz = fread(main->code, sizeof(operation), main->codesz, bcf);
  if (codesz != main->codesz) {
    fprintf(stderr, "Error reading bytecode in file\n");
    free(main->code);
    free(main);
    return NULL;
  }
{% endhighlight %}



# interpret bytecode (running VM)
Long story short: an interpreter is a "for loop", walking through bytecode and making actions regarding to the opcode and parameters.
For your small language, the virtual machine looks like: 

{% highlight c %}
int64_t execute(function *fmain)
{
  int pc;
  int64_t ret = 0;
  operation op;

  /* walking through main function */
  for(pc = 0; pc < fmain->codesz; pc++) {
    op = fmain->code[pc];
    switch(op.op) {
      /* On return, get the return value from parameters and exit */
      case OP_RETURN:
        ret = op.param;
        break;
      /* Handle error case */
      case OP_NONE:
      default:
        fprintf(stderr, "Unavailable operand %u\n", op.op);
        exit(1);
    }
  }
  return ret;
}
{% endhighlight %}

Finally, the `main()` function call all previous pieces of code :

{% highlight c %}
int main(int argc, char **argv)
{
  function *fmain;
  int64_t ret = 0;

  if (argc != 2) {
    fprintf(stderr, "usage: %s <file>\n", argv[0]);
    exit(1);
  }
  /* load main function, exit on error */
  fmain = load_main(argv[1]);
  if (!fmain) exit(1);

  /* start interpreter, get return value and print it */
  ret = interpret(fmain);
  fprintf(stdout, "Return value is %lld\n", ret);

  /* cleanly exit from interpreter */
  free_function(fmain);
  exit(0);
}
{% endhighlight %}

# Build
The code is [here](https://github.com/RemiBauzac/jit/tree/first-language-vm). To build the parser, clone the project and run make. The codes build easily on Linux or MacOS:

{% highlight shell %}
$ git clone git@github.com:RemiBauzac/jit.git
$ cd jit && git checkout first-language-vm
$ cd src && make
...
{% endhighlight %}

# Run
To run the vm, just start langvm binary, with out.bc (previously generated by langc) as parameter.

{% highlight shell %}
$ ./langvm out.bc
Return value is 69
{% endhighlight %}
As you can see, the return value is the same you enter in the parser.

# Why out.bc exists ?
I split deliberately interpreting high level language in parser (compiler) and vm (interpreter) to be more instructive.

# What's next
With the next post, let's move to something more serious: first jit compiler. The main objective will be to understand:

* How to allocate executable memory (and the right amount)
* Build binary code
* Jump into executable memory (in order to be executed by processor)
* Jump out (return) to the interpreter

As the first language exemple is really simple, the first jit compiler will be very simple too.


