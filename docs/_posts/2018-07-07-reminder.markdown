---
layout: post
title:  "A bit of theory"
date:   2018-07-07
author: Rémi Bauzac

---

Before dipping into code, a short theorical reminder is required.

# vocabulary

A **source code** is human readable code whose purpose is to be transformed, to be executed after. The source code can be written in different language, each with their own properties (C, C++, Python, Java, Javascript, Ruby, PHP, Go ...).

The **compilation** of source code is a process of transformation into a destination code (called program), in an executable language:

* either by a **virtual machine**;
* or by a processor.

The **compilation** can be divided into several stages of transformation and optimization:

* **source code** lexical analysis
* **source code** parsing
* program generation
* and program optimization

A language is called **compiled** if the program generated by **compilation** is executable by a processor.
The action to execute a compiled language is called **execution**.

A language is called **interpreted** if the program generated by **compilation** is executable by a **virtual machine**.
The action to execute an interpreted language is called **interpretation**.

A **virtual machine** is a program that create an execution environment and interprets the instructions of an **interpreted language** program.
This virtual machine can be interpreted itself by a virtual machine (This is the case of the Jython interpreter that interprets the Python language, while itself is written in Java, itself interpreted by Java virtual machine).

The majority of languages go through a compilation process before being executed or interpreted.
Bash scripts, executed by a **virtual machine** (Bash binary), are an exception. In this case the **source code** is interpreted line by line.

# What is a JiT compiler ?
A JiT compiler (JiT as **J**ust **i**n **T**ime) is a tool used by a **virtual machine** when interpreting a program from a **interpreted language**. This tool is responsible for converting this program (or a part of this program), during the interpretation, to an executable one run directly by the processor, in order to speed up computing. In other words, the interpreter creates a binary program from an **interpreted language**, and runs it on the processor instead of interpreting it.
Most of the time, this transformation is the opportunity to optimize program based on context.

The following table lists different interpreters:

| Interpreted language   | JiT VM |  Project's URL |
|----------------------|--------|----------------|
| PHP |  HHVM | http://hhvm.com |
| Javascript | IonMonkey  | https://wiki.mozilla.org/IonMonkey |
| Java | Oracle JVM, JatoVM | http://www.oracle.com/fr/java/overview/index.html, http://jatovm.org |
| Python | PyPy | http://pypy.org |
| Lua | LuaJit or my own lua JiT project | http://luajit.org|
| Perl | no JiT | |
| Ruby | RuJIT | https://github.com/imasahiro/rujit |
| Tcl  | no JiT | |
| VBScript | no JiT | |

# What's next ?
The next step is to build your first interpreted language, with the help of `lex` and `yacc`. You can start [here](http://jit.bauzac.net/blog/lua-parser)
